// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enums/enums.proto

package dota.enums;

public final class Enums {
  private Enums() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  /**
   * Protobuf enum {@code AttackType}
   *
   * <pre>
   * 攻击类型
   * </pre>
   */
  public enum AttackType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>PHYSICAL = 1;</code>
     *
     * <pre>
     * 物理伤害
     * </pre>
     */
    PHYSICAL(0, 1),
    /**
     * <code>MAGICAL = 2;</code>
     *
     * <pre>
     * 魔法伤害
     * </pre>
     */
    MAGICAL(1, 2),
    ;

    /**
     * <code>PHYSICAL = 1;</code>
     *
     * <pre>
     * 物理伤害
     * </pre>
     */
    public static final int PHYSICAL_VALUE = 1;
    /**
     * <code>MAGICAL = 2;</code>
     *
     * <pre>
     * 魔法伤害
     * </pre>
     */
    public static final int MAGICAL_VALUE = 2;


    public final int getNumber() { return value; }

    public static AttackType valueOf(int value) {
      switch (value) {
        case 1: return PHYSICAL;
        case 2: return MAGICAL;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AttackType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<AttackType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AttackType>() {
            public AttackType findValueByNumber(int number) {
              return AttackType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return dota.enums.Enums.getDescriptor().getEnumTypes().get(0);
    }

    private static final AttackType[] VALUES = values();

    public static AttackType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private AttackType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:AttackType)
  }

  /**
   * Protobuf enum {@code CombatState}
   *
   * <pre>
   * 战斗状态
   * </pre>
   */
  public enum CombatState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>STUN = 1;</code>
     *
     * <pre>
     * 眩晕
     * </pre>
     */
    STUN(0, 1),
    ;

    /**
     * <code>STUN = 1;</code>
     *
     * <pre>
     * 眩晕
     * </pre>
     */
    public static final int STUN_VALUE = 1;


    public final int getNumber() { return value; }

    public static CombatState valueOf(int value) {
      switch (value) {
        case 1: return STUN;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CombatState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<CombatState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CombatState>() {
            public CombatState findValueByNumber(int number) {
              return CombatState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return dota.enums.Enums.getDescriptor().getEnumTypes().get(1);
    }

    private static final CombatState[] VALUES = values();

    public static CombatState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private CombatState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:CombatState)
  }

  /**
   * Protobuf enum {@code HeroType}
   *
   * <pre>
   * 英雄类型
   * </pre>
   */
  public enum HeroType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>STRENGTH = 1;</code>
     */
    STRENGTH(0, 1),
    /**
     * <code>AGILITY = 2;</code>
     */
    AGILITY(1, 2),
    /**
     * <code>INTELLIGENCE = 3;</code>
     */
    INTELLIGENCE(2, 3),
    ;

    /**
     * <code>STRENGTH = 1;</code>
     */
    public static final int STRENGTH_VALUE = 1;
    /**
     * <code>AGILITY = 2;</code>
     */
    public static final int AGILITY_VALUE = 2;
    /**
     * <code>INTELLIGENCE = 3;</code>
     */
    public static final int INTELLIGENCE_VALUE = 3;


    public final int getNumber() { return value; }

    public static HeroType valueOf(int value) {
      switch (value) {
        case 1: return STRENGTH;
        case 2: return AGILITY;
        case 3: return INTELLIGENCE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<HeroType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<HeroType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<HeroType>() {
            public HeroType findValueByNumber(int number) {
              return HeroType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return dota.enums.Enums.getDescriptor().getEnumTypes().get(2);
    }

    private static final HeroType[] VALUES = values();

    public static HeroType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private HeroType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:HeroType)
  }

  /**
   * Protobuf enum {@code SkillType}
   *
   * <pre>
   * 技能类型
   * </pre>
   */
  public enum SkillType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>COMMON = 1;</code>
     *
     * <pre>
     * 普通攻击
     * </pre>
     */
    COMMON(0, 1),
    /**
     * <code>FISSURE = 11;</code>
     *
     * <pre>
     * 沟壑
     * </pre>
     */
    FISSURE(1, 11),
    /**
     * <code>ENCHANTTOTEM = 12;</code>
     *
     * <pre>
     * 强化图腾
     * </pre>
     */
    ENCHANTTOTEM(2, 12),
    /**
     * <code>AFTERSHOCK = 13;</code>
     *
     * <pre>
     * 余震
     * </pre>
     */
    AFTERSHOCK(3, 13),
    /**
     * <code>ECHOSLAM = 14;</code>
     *
     * <pre>
     * 回音击
     * </pre>
     */
    ECHOSLAM(4, 14),
    /**
     * <code>STORMBOLT = 21;</code>
     *
     * <pre>
     * 风暴之锤
     * </pre>
     */
    STORMBOLT(5, 21),
    /**
     * <code>GREATCLEAVE = 22;</code>
     *
     * <pre>
     * 巨力挥舞
     * </pre>
     */
    GREATCLEAVE(6, 22),
    /**
     * <code>WARCRY = 23;</code>
     *
     * <pre>
     * 战吼
     * </pre>
     */
    WARCRY(7, 23),
    /**
     * <code>GODSSTRENGTH = 24;</code>
     *
     * <pre>
     * 神之力量
     * </pre>
     */
    GODSSTRENGTH(8, 24),
    ;

    /**
     * <code>COMMON = 1;</code>
     *
     * <pre>
     * 普通攻击
     * </pre>
     */
    public static final int COMMON_VALUE = 1;
    /**
     * <code>FISSURE = 11;</code>
     *
     * <pre>
     * 沟壑
     * </pre>
     */
    public static final int FISSURE_VALUE = 11;
    /**
     * <code>ENCHANTTOTEM = 12;</code>
     *
     * <pre>
     * 强化图腾
     * </pre>
     */
    public static final int ENCHANTTOTEM_VALUE = 12;
    /**
     * <code>AFTERSHOCK = 13;</code>
     *
     * <pre>
     * 余震
     * </pre>
     */
    public static final int AFTERSHOCK_VALUE = 13;
    /**
     * <code>ECHOSLAM = 14;</code>
     *
     * <pre>
     * 回音击
     * </pre>
     */
    public static final int ECHOSLAM_VALUE = 14;
    /**
     * <code>STORMBOLT = 21;</code>
     *
     * <pre>
     * 风暴之锤
     * </pre>
     */
    public static final int STORMBOLT_VALUE = 21;
    /**
     * <code>GREATCLEAVE = 22;</code>
     *
     * <pre>
     * 巨力挥舞
     * </pre>
     */
    public static final int GREATCLEAVE_VALUE = 22;
    /**
     * <code>WARCRY = 23;</code>
     *
     * <pre>
     * 战吼
     * </pre>
     */
    public static final int WARCRY_VALUE = 23;
    /**
     * <code>GODSSTRENGTH = 24;</code>
     *
     * <pre>
     * 神之力量
     * </pre>
     */
    public static final int GODSSTRENGTH_VALUE = 24;


    public final int getNumber() { return value; }

    public static SkillType valueOf(int value) {
      switch (value) {
        case 1: return COMMON;
        case 11: return FISSURE;
        case 12: return ENCHANTTOTEM;
        case 13: return AFTERSHOCK;
        case 14: return ECHOSLAM;
        case 21: return STORMBOLT;
        case 22: return GREATCLEAVE;
        case 23: return WARCRY;
        case 24: return GODSSTRENGTH;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SkillType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<SkillType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SkillType>() {
            public SkillType findValueByNumber(int number) {
              return SkillType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return dota.enums.Enums.getDescriptor().getEnumTypes().get(3);
    }

    private static final SkillType[] VALUES = values();

    public static SkillType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private SkillType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:SkillType)
  }

  /**
   * Protobuf enum {@code SkillEmitType}
   *
   * <pre>
   * 技能释放类型
   * </pre>
   */
  public enum SkillEmitType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>PASSIVE = 0;</code>
     */
    PASSIVE(0, 0),
    /**
     * <code>ACTIEVE = 1;</code>
     */
    ACTIEVE(1, 1),
    ;

    /**
     * <code>PASSIVE = 0;</code>
     */
    public static final int PASSIVE_VALUE = 0;
    /**
     * <code>ACTIEVE = 1;</code>
     */
    public static final int ACTIEVE_VALUE = 1;


    public final int getNumber() { return value; }

    public static SkillEmitType valueOf(int value) {
      switch (value) {
        case 0: return PASSIVE;
        case 1: return ACTIEVE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<SkillEmitType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<SkillEmitType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<SkillEmitType>() {
            public SkillEmitType findValueByNumber(int number) {
              return SkillEmitType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return dota.enums.Enums.getDescriptor().getEnumTypes().get(4);
    }

    private static final SkillEmitType[] VALUES = values();

    public static SkillEmitType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private SkillEmitType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:SkillEmitType)
  }

  /**
   * Protobuf enum {@code BuffType}
   *
   * <pre>
   * BUF
   * </pre>
   */
  public enum BuffType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>ENCHANTTOTEMBUFF = 1;</code>
     */
    ENCHANTTOTEMBUFF(0, 1),
    /**
     * <code>AFTERSHOCKBUFF = 2;</code>
     */
    AFTERSHOCKBUFF(1, 2),
    /**
     * <code>GREATCLEAVEBUFF = 3;</code>
     */
    GREATCLEAVEBUFF(2, 3),
    /**
     * <code>WARCRYBUFF = 4;</code>
     */
    WARCRYBUFF(3, 4),
    /**
     * <code>GODSSTRENGTHBUFF = 5;</code>
     */
    GODSSTRENGTHBUFF(4, 5),
    ;

    /**
     * <code>ENCHANTTOTEMBUFF = 1;</code>
     */
    public static final int ENCHANTTOTEMBUFF_VALUE = 1;
    /**
     * <code>AFTERSHOCKBUFF = 2;</code>
     */
    public static final int AFTERSHOCKBUFF_VALUE = 2;
    /**
     * <code>GREATCLEAVEBUFF = 3;</code>
     */
    public static final int GREATCLEAVEBUFF_VALUE = 3;
    /**
     * <code>WARCRYBUFF = 4;</code>
     */
    public static final int WARCRYBUFF_VALUE = 4;
    /**
     * <code>GODSSTRENGTHBUFF = 5;</code>
     */
    public static final int GODSSTRENGTHBUFF_VALUE = 5;


    public final int getNumber() { return value; }

    public static BuffType valueOf(int value) {
      switch (value) {
        case 1: return ENCHANTTOTEMBUFF;
        case 2: return AFTERSHOCKBUFF;
        case 3: return GREATCLEAVEBUFF;
        case 4: return WARCRYBUFF;
        case 5: return GODSSTRENGTHBUFF;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<BuffType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<BuffType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<BuffType>() {
            public BuffType findValueByNumber(int number) {
              return BuffType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return dota.enums.Enums.getDescriptor().getEnumTypes().get(5);
    }

    private static final BuffType[] VALUES = values();

    public static BuffType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private BuffType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:BuffType)
  }


  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\021enums/enums.proto*\'\n\nAttackType\022\014\n\010PHY" +
      "SICAL\020\001\022\013\n\007MAGICAL\020\002*\027\n\013CombatState\022\010\n\004S" +
      "TUN\020\001*7\n\010HeroType\022\014\n\010STRENGTH\020\001\022\013\n\007AGILI" +
      "TY\020\002\022\020\n\014INTELLIGENCE\020\003*\222\001\n\tSkillType\022\n\n\006" +
      "COMMON\020\001\022\013\n\007FISSURE\020\013\022\020\n\014ENCHANTTOTEM\020\014\022" +
      "\016\n\nAFTERSHOCK\020\r\022\014\n\010ECHOSLAM\020\016\022\r\n\tSTORMBO" +
      "LT\020\025\022\017\n\013GREATCLEAVE\020\026\022\n\n\006WARCRY\020\027\022\020\n\014GOD" +
      "SSTRENGTH\020\030*)\n\rSkillEmitType\022\013\n\007PASSIVE\020" +
      "\000\022\013\n\007ACTIEVE\020\001*o\n\010BuffType\022\024\n\020ENCHANTTOT" +
      "EMBUFF\020\001\022\022\n\016AFTERSHOCKBUFF\020\002\022\023\n\017GREATCLE",
      "AVEBUFF\020\003\022\016\n\nWARCRYBUFF\020\004\022\024\n\020GODSSTRENGT" +
      "HBUFF\020\005B\014\n\ndota.enums"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
        public com.google.protobuf.ExtensionRegistry assignDescriptors(
            com.google.protobuf.Descriptors.FileDescriptor root) {
          descriptor = root;
          return null;
        }
      };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
  }

  // @@protoc_insertion_point(outer_class_scope)
}
